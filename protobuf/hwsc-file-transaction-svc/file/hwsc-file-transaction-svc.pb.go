// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protobuf/hwsc-file-transaction-svc/file/hwsc-file-transaction-svc.proto

package file

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	lib "github.com/hwsc-org/hwsc-api-blocks/protobuf/lib"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FileTransactionRequest struct {
	Identification       *lib.Identification `protobuf:"bytes,1,opt,name=identification,proto3" json:"identification,omitempty"`
	Message              string              `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Name                 string              `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Uuid                 string              `protobuf:"bytes,4,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Urls                 []string            `protobuf:"bytes,5,rep,name=urls,proto3" json:"urls,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *FileTransactionRequest) Reset()         { *m = FileTransactionRequest{} }
func (m *FileTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*FileTransactionRequest) ProtoMessage()    {}
func (*FileTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3002186fb7561ac5, []int{0}
}

func (m *FileTransactionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileTransactionRequest.Unmarshal(m, b)
}
func (m *FileTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileTransactionRequest.Marshal(b, m, deterministic)
}
func (m *FileTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransactionRequest.Merge(m, src)
}
func (m *FileTransactionRequest) XXX_Size() int {
	return xxx_messageInfo_FileTransactionRequest.Size(m)
}
func (m *FileTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransactionRequest proto.InternalMessageInfo

func (m *FileTransactionRequest) GetIdentification() *lib.Identification {
	if m != nil {
		return m.Identification
	}
	return nil
}

func (m *FileTransactionRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *FileTransactionRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileTransactionRequest) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *FileTransactionRequest) GetUrls() []string {
	if m != nil {
		return m.Urls
	}
	return nil
}

type FileTransactionResponse struct {
	// Types that are valid to be assigned to Status:
	//	*FileTransactionResponse_Code
	Status               isFileTransactionResponse_Status `protobuf_oneof:"status"`
	Message              string                           `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Url                  string                           `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *FileTransactionResponse) Reset()         { *m = FileTransactionResponse{} }
func (m *FileTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*FileTransactionResponse) ProtoMessage()    {}
func (*FileTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3002186fb7561ac5, []int{1}
}

func (m *FileTransactionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileTransactionResponse.Unmarshal(m, b)
}
func (m *FileTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileTransactionResponse.Marshal(b, m, deterministic)
}
func (m *FileTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransactionResponse.Merge(m, src)
}
func (m *FileTransactionResponse) XXX_Size() int {
	return xxx_messageInfo_FileTransactionResponse.Size(m)
}
func (m *FileTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransactionResponse proto.InternalMessageInfo

type isFileTransactionResponse_Status interface {
	isFileTransactionResponse_Status()
}

type FileTransactionResponse_Code struct {
	Code uint32 `protobuf:"varint,1,opt,name=code,proto3,oneof"`
}

func (*FileTransactionResponse_Code) isFileTransactionResponse_Status() {}

func (m *FileTransactionResponse) GetStatus() isFileTransactionResponse_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *FileTransactionResponse) GetCode() uint32 {
	if x, ok := m.GetStatus().(*FileTransactionResponse_Code); ok {
		return x.Code
	}
	return 0
}

func (m *FileTransactionResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *FileTransactionResponse) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FileTransactionResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FileTransactionResponse_Code)(nil),
	}
}

type Chunk struct {
	// Types that are valid to be assigned to IsOneOf:
	//	*Chunk_Identification
	//	*Chunk_Buffer
	//	*Chunk_Length
	//	*Chunk_FileName
	//	*Chunk_Uuid
	IsOneOf              isChunk_IsOneOf `protobuf_oneof:"is_one_of"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Chunk) Reset()         { *m = Chunk{} }
func (m *Chunk) String() string { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()    {}
func (*Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_3002186fb7561ac5, []int{2}
}

func (m *Chunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Chunk.Unmarshal(m, b)
}
func (m *Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Chunk.Marshal(b, m, deterministic)
}
func (m *Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chunk.Merge(m, src)
}
func (m *Chunk) XXX_Size() int {
	return xxx_messageInfo_Chunk.Size(m)
}
func (m *Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_Chunk proto.InternalMessageInfo

type isChunk_IsOneOf interface {
	isChunk_IsOneOf()
}

type Chunk_Identification struct {
	Identification *lib.Identification `protobuf:"bytes,1,opt,name=identification,proto3,oneof"`
}

type Chunk_Buffer struct {
	Buffer []byte `protobuf:"bytes,2,opt,name=buffer,proto3,oneof"`
}

type Chunk_Length struct {
	Length int64 `protobuf:"varint,3,opt,name=length,proto3,oneof"`
}

type Chunk_FileName struct {
	FileName string `protobuf:"bytes,4,opt,name=file_name,json=fileName,proto3,oneof"`
}

type Chunk_Uuid struct {
	Uuid string `protobuf:"bytes,5,opt,name=uuid,proto3,oneof"`
}

func (*Chunk_Identification) isChunk_IsOneOf() {}

func (*Chunk_Buffer) isChunk_IsOneOf() {}

func (*Chunk_Length) isChunk_IsOneOf() {}

func (*Chunk_FileName) isChunk_IsOneOf() {}

func (*Chunk_Uuid) isChunk_IsOneOf() {}

func (m *Chunk) GetIsOneOf() isChunk_IsOneOf {
	if m != nil {
		return m.IsOneOf
	}
	return nil
}

func (m *Chunk) GetIdentification() *lib.Identification {
	if x, ok := m.GetIsOneOf().(*Chunk_Identification); ok {
		return x.Identification
	}
	return nil
}

func (m *Chunk) GetBuffer() []byte {
	if x, ok := m.GetIsOneOf().(*Chunk_Buffer); ok {
		return x.Buffer
	}
	return nil
}

func (m *Chunk) GetLength() int64 {
	if x, ok := m.GetIsOneOf().(*Chunk_Length); ok {
		return x.Length
	}
	return 0
}

func (m *Chunk) GetFileName() string {
	if x, ok := m.GetIsOneOf().(*Chunk_FileName); ok {
		return x.FileName
	}
	return ""
}

func (m *Chunk) GetUuid() string {
	if x, ok := m.GetIsOneOf().(*Chunk_Uuid); ok {
		return x.Uuid
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Chunk) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Chunk_Identification)(nil),
		(*Chunk_Buffer)(nil),
		(*Chunk_Length)(nil),
		(*Chunk_FileName)(nil),
		(*Chunk_Uuid)(nil),
	}
}

func init() {
	proto.RegisterType((*FileTransactionRequest)(nil), "file.FileTransactionRequest")
	proto.RegisterType((*FileTransactionResponse)(nil), "file.FileTransactionResponse")
	proto.RegisterType((*Chunk)(nil), "file.Chunk")
}

func init() {
	proto.RegisterFile("protobuf/hwsc-file-transaction-svc/file/hwsc-file-transaction-svc.proto", fileDescriptor_3002186fb7561ac5)
}

var fileDescriptor_3002186fb7561ac5 = []byte{
	// 460 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x53, 0x4d, 0x6f, 0x13, 0x31,
	0x10, 0xdd, 0x6d, 0x3e, 0x68, 0x26, 0x80, 0x2a, 0xb7, 0x82, 0x55, 0xd5, 0x4a, 0xd1, 0x9e, 0x72,
	0xc9, 0x06, 0x95, 0x23, 0x70, 0x49, 0xab, 0x36, 0x80, 0x40, 0x62, 0x4b, 0x2f, 0xbd, 0x44, 0x5e,
	0xef, 0x6c, 0xd6, 0xaa, 0x63, 0x2f, 0xfe, 0x68, 0xc5, 0x6f, 0xe2, 0x27, 0xc0, 0x8f, 0x43, 0xf6,
	0x86, 0xcf, 0xb6, 0x14, 0xc4, 0x6d, 0xe6, 0xbd, 0xf1, 0xf3, 0xf3, 0x1b, 0x19, 0x4e, 0x1a, 0xad,
	0xac, 0x2a, 0x5c, 0x35, 0xad, 0xaf, 0x0c, 0x9b, 0x54, 0x5c, 0xe0, 0xc4, 0x6a, 0x2a, 0x0d, 0x65,
	0x96, 0x2b, 0x39, 0x31, 0x97, 0x6c, 0xea, 0xc1, 0xdb, 0xe9, 0x2c, 0x28, 0x90, 0xae, 0xe7, 0x76,
	0xf7, 0xbe, 0xcb, 0x09, 0x5e, 0x4c, 0xa9, 0xb3, 0xb5, 0xd2, 0xdc, 0x7e, 0x6c, 0x67, 0xd2, 0x4f,
	0x31, 0x3c, 0x3a, 0xe6, 0x02, 0xdf, 0xff, 0x50, 0xc8, 0xf1, 0x83, 0x43, 0x63, 0xc9, 0x33, 0x78,
	0xc8, 0x4b, 0x94, 0x96, 0x57, 0x9c, 0x51, 0x4f, 0x24, 0xf1, 0x28, 0x1e, 0x0f, 0x0f, 0xb6, 0x33,
	0xc1, 0x8b, 0xec, 0xe5, 0x2f, 0x54, 0xfe, 0xdb, 0x28, 0x49, 0xe0, 0xde, 0x0a, 0x8d, 0xa1, 0x4b,
	0x4c, 0x36, 0x46, 0xf1, 0x78, 0x90, 0x7f, 0x6b, 0x09, 0x81, 0xae, 0xa4, 0x2b, 0x4c, 0x3a, 0x01,
	0x0e, 0xb5, 0xc7, 0x9c, 0xe3, 0x65, 0xd2, 0x6d, 0x31, 0x5f, 0x07, 0x4c, 0x0b, 0x93, 0xf4, 0x46,
	0x9d, 0x80, 0x69, 0x61, 0x52, 0x84, 0xc7, 0xd7, 0xcc, 0x9a, 0x46, 0x49, 0x83, 0x64, 0x07, 0xba,
	0x4c, 0x95, 0x18, 0x3c, 0x3e, 0x98, 0x47, 0x79, 0xe8, 0xfe, 0x60, 0x63, 0x0b, 0x3a, 0x4e, 0x8b,
	0xb5, 0x0b, 0x5f, 0xce, 0x36, 0xa1, 0x6f, 0x2c, 0xb5, 0xce, 0xa4, 0x5f, 0x62, 0xe8, 0x1d, 0xd6,
	0x4e, 0x5e, 0x90, 0x17, 0xff, 0x90, 0xc1, 0x3c, 0xba, 0x21, 0x85, 0x7e, 0xe1, 0xaa, 0x0a, 0x75,
	0xb8, 0xfd, 0xfe, 0x3c, 0xca, 0xd7, 0xbd, 0x67, 0x04, 0xca, 0xa5, 0xad, 0x83, 0x83, 0x8e, 0x67,
	0xda, 0x9e, 0xec, 0xc3, 0xc0, 0xef, 0x6d, 0x11, 0x42, 0x0a, 0x81, 0xcc, 0xa3, 0x7c, 0xd3, 0x43,
	0x6f, 0x7d, 0x54, 0x3b, 0xeb, 0xa8, 0x7a, 0x6b, 0x26, 0x74, 0xb3, 0x21, 0x0c, 0xb8, 0x59, 0x28,
	0x89, 0x0b, 0x55, 0x1d, 0x7c, 0xde, 0xb8, 0xb6, 0xd3, 0x53, 0xd4, 0x97, 0x9c, 0x21, 0x79, 0x05,
	0x83, 0x13, 0xb4, 0xa7, 0xe1, 0x99, 0x64, 0x2f, 0xf3, 0xaa, 0xd9, 0xcd, 0xeb, 0xdf, 0xdd, 0xbf,
	0x85, 0x6d, 0xf3, 0x4e, 0x23, 0xf2, 0x1c, 0xe0, 0xac, 0x11, 0x8a, 0x96, 0x7e, 0x84, 0x0c, 0xdb,
	0xf1, 0x10, 0xdb, 0x9d, 0x67, 0xc7, 0x31, 0x39, 0x82, 0xed, 0x23, 0x75, 0x25, 0xfd, 0xf9, 0x73,
	0xde, 0x34, 0x18, 0x54, 0xee, 0xf2, 0xf4, 0xf3, 0x25, 0x69, 0xf4, 0x24, 0x26, 0xef, 0x60, 0xeb,
	0x50, 0x23, 0xb5, 0x78, 0x66, 0x50, 0x1f, 0x2b, 0x51, 0xa2, 0xfe, 0xcf, 0x67, 0xcd, 0xde, 0x9c,
	0xbf, 0x5e, 0x72, 0x5b, 0xbb, 0x22, 0x63, 0x6a, 0xd5, 0xfe, 0x31, 0xa5, 0x97, 0x6d, 0x41, 0x1b,
	0x3e, 0x29, 0x84, 0x62, 0x17, 0x66, 0xfa, 0x97, 0x9f, 0xb4, 0xe8, 0x87, 0xc1, 0xa7, 0x5f, 0x03,
	0x00, 0x00, 0xff, 0xff, 0xe4, 0x2d, 0xb1, 0x5c, 0xd6, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FileTransactionServiceClient is the client API for FileTransactionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileTransactionServiceClient interface {
	// Gets status for user
	GetStatus(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (*FileTransactionResponse, error)
	// Upload files to the storage
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (FileTransactionService_UploadFileClient, error)
	// Download files from the storage
	DownloadZippedFiles(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (FileTransactionService_DownloadZippedFilesClient, error)
	// Create user folder in the sorage
	CreateUserFolder(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (*FileTransactionResponse, error)
}

type fileTransactionServiceClient struct {
	cc *grpc.ClientConn
}

func NewFileTransactionServiceClient(cc *grpc.ClientConn) FileTransactionServiceClient {
	return &fileTransactionServiceClient{cc}
}

func (c *fileTransactionServiceClient) GetStatus(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (*FileTransactionResponse, error) {
	out := new(FileTransactionResponse)
	err := c.cc.Invoke(ctx, "/file.FileTransactionService/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileTransactionServiceClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (FileTransactionService_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileTransactionService_serviceDesc.Streams[0], "/file.FileTransactionService/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileTransactionServiceUploadFileClient{stream}
	return x, nil
}

type FileTransactionService_UploadFileClient interface {
	Send(*Chunk) error
	CloseAndRecv() (*FileTransactionResponse, error)
	grpc.ClientStream
}

type fileTransactionServiceUploadFileClient struct {
	grpc.ClientStream
}

func (x *fileTransactionServiceUploadFileClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileTransactionServiceUploadFileClient) CloseAndRecv() (*FileTransactionResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(FileTransactionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileTransactionServiceClient) DownloadZippedFiles(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (FileTransactionService_DownloadZippedFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileTransactionService_serviceDesc.Streams[1], "/file.FileTransactionService/DownloadZippedFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileTransactionServiceDownloadZippedFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileTransactionService_DownloadZippedFilesClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type fileTransactionServiceDownloadZippedFilesClient struct {
	grpc.ClientStream
}

func (x *fileTransactionServiceDownloadZippedFilesClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileTransactionServiceClient) CreateUserFolder(ctx context.Context, in *FileTransactionRequest, opts ...grpc.CallOption) (*FileTransactionResponse, error) {
	out := new(FileTransactionResponse)
	err := c.cc.Invoke(ctx, "/file.FileTransactionService/CreateUserFolder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileTransactionServiceServer is the server API for FileTransactionService service.
type FileTransactionServiceServer interface {
	// Gets status for user
	GetStatus(context.Context, *FileTransactionRequest) (*FileTransactionResponse, error)
	// Upload files to the storage
	UploadFile(FileTransactionService_UploadFileServer) error
	// Download files from the storage
	DownloadZippedFiles(*FileTransactionRequest, FileTransactionService_DownloadZippedFilesServer) error
	// Create user folder in the sorage
	CreateUserFolder(context.Context, *FileTransactionRequest) (*FileTransactionResponse, error)
}

// UnimplementedFileTransactionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedFileTransactionServiceServer struct {
}

func (*UnimplementedFileTransactionServiceServer) GetStatus(ctx context.Context, req *FileTransactionRequest) (*FileTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (*UnimplementedFileTransactionServiceServer) UploadFile(srv FileTransactionService_UploadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (*UnimplementedFileTransactionServiceServer) DownloadZippedFiles(req *FileTransactionRequest, srv FileTransactionService_DownloadZippedFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadZippedFiles not implemented")
}
func (*UnimplementedFileTransactionServiceServer) CreateUserFolder(ctx context.Context, req *FileTransactionRequest) (*FileTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserFolder not implemented")
}

func RegisterFileTransactionServiceServer(s *grpc.Server, srv FileTransactionServiceServer) {
	s.RegisterService(&_FileTransactionService_serviceDesc, srv)
}

func _FileTransactionService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileTransactionServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileTransactionService/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileTransactionServiceServer).GetStatus(ctx, req.(*FileTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileTransactionService_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileTransactionServiceServer).UploadFile(&fileTransactionServiceUploadFileServer{stream})
}

type FileTransactionService_UploadFileServer interface {
	SendAndClose(*FileTransactionResponse) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type fileTransactionServiceUploadFileServer struct {
	grpc.ServerStream
}

func (x *fileTransactionServiceUploadFileServer) SendAndClose(m *FileTransactionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileTransactionServiceUploadFileServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileTransactionService_DownloadZippedFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileTransactionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileTransactionServiceServer).DownloadZippedFiles(m, &fileTransactionServiceDownloadZippedFilesServer{stream})
}

type FileTransactionService_DownloadZippedFilesServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type fileTransactionServiceDownloadZippedFilesServer struct {
	grpc.ServerStream
}

func (x *fileTransactionServiceDownloadZippedFilesServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _FileTransactionService_CreateUserFolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileTransactionServiceServer).CreateUserFolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileTransactionService/CreateUserFolder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileTransactionServiceServer).CreateUserFolder(ctx, req.(*FileTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileTransactionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "file.FileTransactionService",
	HandlerType: (*FileTransactionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStatus",
			Handler:    _FileTransactionService_GetStatus_Handler,
		},
		{
			MethodName: "CreateUserFolder",
			Handler:    _FileTransactionService_CreateUserFolder_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFile",
			Handler:       _FileTransactionService_UploadFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadZippedFiles",
			Handler:       _FileTransactionService_DownloadZippedFiles_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protobuf/hwsc-file-transaction-svc/file/hwsc-file-transaction-svc.proto",
}
